
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>js回顾加深 - Chaoer&#39;blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="个人博客，主要记录学习笔记,Js 加深与理解1.变量声明的区别1.1var 关键字声明作用域: 使用 var 操作符定义的变量会变成为包含它的函数的局部变量
12345function test() &amp;#123;  var m,"> 
    <meta name="author" content="Chaoer"> 
    <link rel="alternative" href="atom.xml" title="Chaoer&#39;blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Chaoer&#39;blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://blackchao-script.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">js回顾加深</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">js回顾加深</h1>
        <div class="stuff">
            <span>九月 13, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/js/" rel="tag">js</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Js-加深与理解"><a href="#Js-加深与理解" class="headerlink" title="Js 加深与理解"></a>Js 加深与理解</h1><h2 id="1-变量声明的区别"><a href="#1-变量声明的区别" class="headerlink" title="1.变量声明的区别"></a>1.变量声明的区别</h2><h3 id="1-1var-关键字"><a href="#1-1var-关键字" class="headerlink" title="1.1var 关键字"></a>1.1var 关键字</h3><p><strong>声明作用域</strong>: 使用 var 操作符定义的变量会变成为包含它的函数的局部变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&#x27;你好&#x27;</span> <span class="comment">//局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//出错</span></span><br></pre></td></tr></table></figure>

<p>这里的 message 变量是用 var 再函数内部声明的,所以再调用 text( )函数时，它会创建这个变量并给它赋值。调用完成之后就会被销毁，所以示例的最后一行才会出错。</p>
<p><strong>var 声明提升</strong>: 使用 var 操作符定义的变量会自动提升到函数作用域的顶部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价域如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">  message = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-let-声明"><a href="#1-2-let-声明" class="headerlink" title="1.2 let 声明"></a>1.2 let 声明</h3><p><strong>声明作用域</strong>: 使用 let 关键字声明的范围时块作用域</p>
<p>使用 var 是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(age) <span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>使用 let 是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(age) <span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">//age没有定义</span></span><br></pre></td></tr></table></figure>

<p><strong>不允许出现重复声明</strong>: let 不允许在同一个块作用域中出现重复声明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name</span><br><span class="line"><span class="keyword">var</span> name</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age</span><br><span class="line"><span class="keyword">let</span> age <span class="comment">//标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>

<p><strong>暂时性死区</strong>: let 声明的变量不会在作用域中被提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consloe.log(sex) <span class="comment">//sex没有定义</span></span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>全局声明</strong>: let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//&#x27;小明&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>条件声明</strong>: 在使用 var 变量声明是,由于声明会被提升，JavaScript 引擎会自动将多余的额声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检测前面是否已经使用 let 声明过同名的变量，同时也就不可能在没有声明的情况下声明它</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;小刚&#x27;</span></span><br><span class="line">	<span class="keyword">let</span> age = <span class="number">20</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//假设脚本在不确定的页面中是否已经声明了同名变量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//那它可以假设还没有声明过</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//这里不会报错，因为可能被作为一个提升声明来处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//不需要在检查之间是否声明过同名变量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">let</span> age = <span class="number">39</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//如果age之前声明过，这里会报错</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>for 循环中的 let 声明</strong>：在 let 出现之前，for 循环迭代的变量可以在循环体外部使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>改成 let 就消失了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">consloe.log(i) <span class="comment">//i没有定义</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3const-声明"><a href="#1-3const-声明" class="headerlink" title="1.3const 声明"></a>1.3const 声明</h3><p><strong>const 的行为与 let 基本相同</strong>，唯一一个重要的区别就是它声明的变量必须同时初始化变量，且尝试修改 const 声明的变量会导致运行错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line">age = <span class="number">21</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p><strong>不能使用 const 来声明迭代变量(因为迭代变量会自增)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span><span class="string">&#x27; i++)&#123;&#125; //error</span></span><br></pre></td></tr></table></figure>

<h2 id="2-js-的输出与输入"><a href="#2-js-的输出与输入" class="headerlink" title="2.js 的输出与输入"></a>2.js 的输出与输入</h2><h3 id="2-1-输出"><a href="#2-1-输出" class="headerlink" title="2.1 输出"></a>2.1 输出</h3><ul>
<li><strong>alert</strong>(‘提示内容’)；弹出警告框</li>
<li><strong>document.write</strong>(‘提示内容’); 向文档流中打印输出内容</li>
<li><strong>console.log</strong>(“提示内容”); 向控制台输出日志信息</li>
</ul>
<h3 id="2-2-输入"><a href="#2-2-输入" class="headerlink" title="2.2 输入"></a>2.2 输入</h3><ul>
<li><p><strong>prompt</strong> (提示信息,默认值)</p>
<p>用户点击确定按钮,得到输入值</p>
<p>取消得到 Null</p>
</li>
<li><p><strong>confirm</strong> (确定对话框)</p>
<p>可以用变量接收它的结果，用户点击确定返回 true，用户点击取消返回 false.</p>
</li>
<li><p>表单中的输入框</p>
</li>
</ul>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p>JavaScript 的数据类型分为两种，一种是基本数据类型，一种是引用数据类型</p>
<h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><ul>
<li>Number –(数字)</li>
<li>String –(字符串)</li>
<li>Boolean –(布尔值)</li>
<li>Undefined –(未定义)</li>
<li>Null –(空)</li>
<li>Symbol –(符号)</li>
</ul>
<h3 id="3-2-引用数据类型"><a href="#3-2-引用数据类型" class="headerlink" title="3.2 引用数据类型"></a>3.2 引用数据类型</h3><p>Object –(对象)</p>
<p>一下都是属于 Object 之内的:</p>
<ul>
<li>Array –(数组)</li>
<li>Function –(函数)</li>
<li>Date –(时间)</li>
<li>RegExp –(正则)</li>
<li>…</li>
</ul>
<h2 id="4-判断-js-变量的数据类型"><a href="#4-判断-js-变量的数据类型" class="headerlink" title="4.判断 js 变量的数据类型"></a>4.判断 js 变量的数据类型</h2><ul>
<li>typeof()</li>
<li>instanceof</li>
<li>constructor</li>
<li>toString</li>
<li>Object.prototype.toString</li>
</ul>
<h2 id="5-数据类型的自动转换和隐式转换"><a href="#5-数据类型的自动转换和隐式转换" class="headerlink" title="5.数据类型的自动转换和隐式转换"></a>5.数据类型的自动转换和隐式转换</h2><h3 id="5-1-隐式转换"><a href="#5-1-隐式转换" class="headerlink" title="5.1 隐式转换"></a>5.1 隐式转换</h3><ul>
<li>1 === ‘1’</li>
<li>‘1’ + 1</li>
<li>‘1’ - 1</li>
</ul>
<h3 id="5-2-自动类型转换"><a href="#5-2-自动类型转换" class="headerlink" title="5.2 自动类型转换"></a>5.2 自动类型转换</h3><ul>
<li><code>parseInt(str,radix)/parseFloat(str,radix)/Number()</code>转变成数字。</li>
<li><code>Boolean(param)</code>转变成布尔值</li>
<li><code>subString()</code>转变成字符串</li>
</ul>
<h2 id="6-“-”-和-“-”-还有-“-”-和-“-”的区别"><a href="#6-“-”-和-“-”-还有-“-”-和-“-”的区别" class="headerlink" title="6.“ == ” 和 “ === ” 还有 “ != ” 和 “ !== ”的区别"></a>6.“ == ” 和 “ === ” 还有 “ != ” 和 “ !== ”的区别</h2><p>“ == ” 和 “ != ”会做数据隐式类型转换，转换完数据类型在做比较。而“ === ” 和 “ !== ”会先判断数据类型，如果俩者的数据类型不一致直接返回 false 就不会再去做值的比较了。</p>
<h2 id="7-return、break-和-continue-的区别"><a href="#7-return、break-和-continue-的区别" class="headerlink" title="7.return、break 和 continue 的区别"></a>7.return、break 和 continue 的区别</h2><h3 id="7-1-return"><a href="#7-1-return" class="headerlink" title="7.1 return"></a>7.1 return</h3><ul>
<li>在函数体中遇到 return 语句,就会结束函数执行（函数体未执行完部分不再执行）</li>
<li>将表达式的值返回到函数调用处</li>
<li>使用 return 最多只能返回一个值</li>
</ul>
<h3 id="7-2-break"><a href="#7-2-break" class="headerlink" title="7.2 break"></a>7.2 break</h3><ul>
<li>break 主要用在循环语句或者 switch 语句中,用来退出整个语句块</li>
<li>break 跳出最里层的循环，并且继续执行该循环下面的语句</li>
<li>break 当用于循环结构时，表示退出其所在的整个循环结构,<strong>当前次循环未完成任务及未完成循环次数将不再执行！</strong></li>
</ul>
<h3 id="7-3-continue"><a href="#7-3-continue" class="headerlink" title="7.3 continue"></a>7.3 continue</h3><ul>
<li>continue 适用于任何循环控制结构中。作用是让程序立即跳转到下一次循环的迭代。</li>
<li>在 for 循环中，continue 语句使程序立即跳转到更新语句。</li>
<li>在 while 或者 do。。。while 循环中，程序立即跳转到布尔表达式的判断语句。</li>
<li><strong>continue 只能用于循环结构</strong>，表示结束当前次循环，还会判断条件进行下一次循环。</li>
</ul>
<h2 id="8-伪数组是什么？伪数组与数组的区别，将伪数组变成真数组"><a href="#8-伪数组是什么？伪数组与数组的区别，将伪数组变成真数组" class="headerlink" title="8.伪数组是什么？伪数组与数组的区别，将伪数组变成真数组"></a>8.伪数组是什么？伪数组与数组的区别，将伪数组变成真数组</h2><h3 id="8-1-伪数组的介绍"><a href="#8-1-伪数组的介绍" class="headerlink" title="8.1 伪数组的介绍"></a>8.1 伪数组的介绍</h3><p>伪数组我们可以理解为类似数组的一个集合，我们常见的有俩个，一个是<strong>arguments</strong>还有一个是<strong>DOM 的 children 属性，获取回来的子节点集合</strong>。他们与数组一样，具有索引(下标)和 length 属性。可以通过 for 循环写循环语句去循环遍历。</p>
<h3 id="8-2-伪数组与数组的区别："><a href="#8-2-伪数组与数组的区别：" class="headerlink" title="8.2 伪数组与数组的区别："></a>8.2 伪数组与数组的区别：</h3><p>伪数组与数组的区别就是它们的<em>proto</em>区别，<br>普通数组有很多数组的方法，比如说 push，shift，map 等等</p>
<p>而伪数组却没有，所以我们称这类解构类似数组却没有数组方法的集合叫做伪数组。</p>
<h2 id="9-面向对象编程-OOP-的概念"><a href="#9-面向对象编程-OOP-的概念" class="headerlink" title="9.面向对象编程(OOP)的概念"></a>9.面向对象编程(OOP)的概念</h2><p>面向对象编程就是基于对象编程，给不同的对象封装不同的方法与属性，通过调用对象的方法和属性实现代码的复用，而且不会全局污染。</p>
<h2 id="10-JS-中的原型和原型链"><a href="#10-JS-中的原型和原型链" class="headerlink" title="10.JS 中的原型和原型链"></a>10.JS 中的原型和原型链</h2><p>讲原型的时候，我们应该先要记住以下几个要点，这几个要点是理解<strong>原型的关键</strong>：</p>
<ul>
<li>所有的引用类型（数组、函数、对象）可以自由扩展属性（除 null 以外）。</li>
<li>所有的引用类型都有一个’_ _ proto_ _‘属性(也叫隐式原型，它是一个普通的对象)。</li>
<li>所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。</li>
<li>所有引用类型，它的’_ _ proto_ _‘属性指向它的构造函数的’prototype’属性。</li>
<li>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _‘属性(也就是它的构造函数的’prototype’属性)中去寻找。</li>
</ul>
<h3 id="10-1-原型"><a href="#10-1-原型" class="headerlink" title="10.1 原型"></a>10.1 原型</h3><p>原型例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*根据要点3，所有的函数都有一个prototype属性，这个属性是一个对象</span></span><br><span class="line"><span class="comment">		再根据要点1，所有的对象可以自由扩展属性</span></span><br><span class="line"><span class="comment">		于是就有了以下写法*/</span></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">  <span class="comment">// prototype对象里面又有其他的属性</span></span><br><span class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m &quot;</span> + <span class="built_in">this</span>.name) <span class="comment">//this是什么要看执行的时候谁调用了这个函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">showAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;And I&#x27;m &quot;</span> + <span class="built_in">this</span>.age) <span class="comment">//this是什么要看执行的时候谁调用了这个函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Foo(<span class="string">&#x27;小明&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="comment">/*当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它</span></span><br><span class="line"><span class="comment">		构造函数的&#x27;prototype&#x27;属性中去找*/</span></span><br><span class="line">fn.showName() <span class="comment">//I&#x27;m 小明</span></span><br><span class="line">fn.showAge() <span class="comment">//And I&#x27;m 19</span></span><br></pre></td></tr></table></figure>

<p>这就是原型，很好理解。那为什么要使用原型呢？</p>
<p>试想如果我们要通过 Foo()来创建<strong>很多很多个</strong>对象，如果我们是这样子写的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;And I&#x27;m &quot;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们创建出来的每一个对象，里面都有 showName 和 showAge 方法，这样就会占用很多的资源。<br>而通过原型来实现的话，只需要在构造函数里面给属性赋值，而把方法写在 Foo.prototype 属性(这个属性是唯一的)里面。这样每个对象都可以使用 prototype 属性里面的 showName、showAge 方法，并且节省了不少的资源。</p>
<h3 id="10-2-原型链"><a href="#10-2-原型链" class="headerlink" title="10.2 原型链"></a>10.2 原型链</h3><p>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它构造函数的’prototype’属性中去寻找。那又因为’prototype’属性是一个对象，所以它也有一个’_ _ proto_ _‘属性。</p>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//this是什么要看执行的时候谁调用了这个函数。</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; And I&#x27;m &quot;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Foo(<span class="string">&#x27;小明&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">fn.toString() <span class="comment">//I&#x27;m 小明 And I&#x27;m 19</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.toString === Foo.prototype.__proto__.toString) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === Foo.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/613dd2d91db7c.jpg" alt="https://www.hualigs.cn/image/613dd2d91db7c.jpg"></p>
<p>首先，fn 的构造函数是 Foo( )。所以: <strong>fn._ _proto _ _ === Foo.prototype</strong></p>
<p>又因为 Foo.prototype 是一个普通的对象，它的构造函数是 Object，所以：<strong>Foo.prototype._ _ proto _ _=== Object.prototype</strong></p>
<p>通过上面的代码，我们知道这个 toString()方法是在 Object.prototype 里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到 null 为止。</p>
<p><strong>所以当 fn 调用 toString()时，JS 发现 fn 中没有这个方法，于是它就去 Foo.prototype 中去找，发现还是没有这个方法，然后就去 Object.prototype 中去找，找到了，就调用 Object.prototype 中的 toString()方法。</strong></p>
<p>这就是原型链，fn 能够调用 Object.prototype 中的方法正是因为存在<strong>原型链</strong>的机制。</p>
<p>另外，在使用原型的时候，一般推荐将需要扩展的方法写在<strong>构造函数的 prototype 属性</strong>中，避免写在_ _ proto _ _属性里面。</p>
<h2 id="11-实现继承的几种方法"><a href="#11-实现继承的几种方法" class="headerlink" title="11.实现继承的几种方法"></a>11.实现继承的几种方法</h2><p><strong>首先定义一个父类：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型上面的方法：</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃:&#x27;</span> + food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下面是实现继承的方法："><a href="#下面是实现继承的方法：" class="headerlink" title="下面是实现继承的方法："></a>下面是实现继承的方法：</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心：将父类的实例作为子类的原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal() <span class="comment">//将Animal的实例挂载到了Dog的原型链上</span></span><br><span class="line"><span class="comment">//或：</span></span><br><span class="line"><span class="comment">//Dog.prototype = Object.create(Animal.prototype)</span></span><br><span class="line">Dog.prototype.name = <span class="string">&#x27;dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">//dog</span></span><br><span class="line">dog.eat(<span class="string">&#x27;bone&#x27;</span>) <span class="comment">//dog正在吃:bone</span></span><br><span class="line">dog.sleep() <span class="comment">//dog正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Animal) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Dog) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问的到</li>
<li>简单</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>要想为子类新增属性和方法，必须要在 new Animal()这样的语句之后执行，不能放到构造器中</li>
<li>无法实现继承多个</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ul>
<h4 id="2-构造继承"><a href="#2-构造继承" class="headerlink" title="2.构造继承"></a>2.构造继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心：使用父类的构造函数增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">//Tom</span></span><br><span class="line">cat.sleep() <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call 多个父类对象）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h4 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心：为父类实例添加新特性，作为子类实例返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal()</span><br><span class="line">  instance.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">//Tom</span></span><br><span class="line">cat.sleep() <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>不限制调用方式，不管是 new 子类()还是子类()，返回的对象都具有相同的效果</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ul>
<h4 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    Cat.prototype[i] = animal[i]</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">//Tom</span></span><br><span class="line">cat.sleep() <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>支持多继承</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>效率极低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（for in 不能访问到的）</li>
</ul>
<h4 id="5-组合继承"><a href="#5-组合继承" class="headerlink" title="5.组合继承"></a>5.组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Cat.prototype.constructor = Cat</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">//Tom</span></span><br><span class="line">cat.sleep() <span class="comment">//Tom正在睡觉</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>弥补了方式 2 的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>函数可复用</li>
<li>可传参</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>调用了俩次构造函数，生成了俩份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ul>
<h4 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心：通过寄生方式，砍掉父类的实例属性，这样，在调用俩次父类的构造的时候，就不会初始化俩次实例方法/属性，避免了组合继承的缺点。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//创建一个没有实例的方法类。</span></span><br><span class="line">  Super.prototype = Animal.prototype</span><br><span class="line">  Cat.prototype = <span class="keyword">new</span> Super() <span class="comment">//将实例作为子类的原型。</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">//Tom</span></span><br><span class="line">cat.sleep() <span class="comment">//Tom正在睡觉</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Cat.prototype.constructor = Cat <span class="comment">//修复构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>基本上是完美的</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来较为复杂</li>
</ul>
<h4 id="7-class-ES6"><a href="#7-class-ES6" class="headerlink" title="7.class - - ES6"></a>7.class - - ES6</h4><p>语法糖，底层任然是原型链继承的方式</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Js-%E5%8A%A0%E6%B7%B1%E4%B8%8E%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Js 加深与理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1.变量声明的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1var-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1var 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-let-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 let 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3const-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3const 声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-js-%E7%9A%84%E8%BE%93%E5%87%BA%E4%B8%8E%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2.js 的输出与输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%A4%E6%96%AD-js-%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">4.判断 js 变量的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.</span> <span class="toc-text">5.数据类型的自动转换和隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 自动类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E2%80%9C-%E2%80%9D-%E5%92%8C-%E2%80%9C-%E2%80%9D-%E8%BF%98%E6%9C%89-%E2%80%9C-%E2%80%9D-%E5%92%8C-%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">6.“ &#x3D;&#x3D; ” 和 “ &#x3D;&#x3D;&#x3D; ” 还有 “ !&#x3D; ” 和 “ !&#x3D;&#x3D; ”的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-return%E3%80%81break-%E5%92%8C-continue-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">7.return、break 和 continue 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-return"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-break"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-continue"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 continue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BC%AA%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%AA%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B0%86%E4%BC%AA%E6%95%B0%E7%BB%84%E5%8F%98%E6%88%90%E7%9C%9F%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.</span> <span class="toc-text">8.伪数组是什么？伪数组与数组的区别，将伪数组变成真数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E4%BC%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 伪数组的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BC%AA%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 伪数组与数组的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-OOP-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.</span> <span class="toc-text">9.面向对象编程(OOP)的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-JS-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.10.</span> <span class="toc-text">10.JS 中的原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">11.实现继承的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.11.1.</span> <span class="toc-text">下面是实现继承的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">1.原型链继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">2.构造继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">3.实例继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">4.拷贝继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.5.</span> <span class="toc-text">5.组合继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.6.</span> <span class="toc-text">6.寄生组合继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-class-ES6"><span class="toc-number">1.11.1.7.</span> <span class="toc-text">7.class - - ES6</span></a></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
